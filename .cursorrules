# Project Rules for Cursor — FollowTheTone

## Stack & Goals
- Backend: Rust + Actix Web
- DB: SurrealDB over HTTP (NS: gear, DB: guitars; env-driven)
- APIs live under `/api/*` for REST endpoints.
- Dev: `cargo run` for development server.

## Must-have Dependencies (Cargo.toml)
[dependencies]
actix-web = "4"
actix-files = "0.6"
actix-cors = "0.7"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
dotenvy = "0.15"
env_logger = "0.11"
log = "0.4"
tokio = { version = "1", features = ["rt-multi-thread","macros"] }

# SurrealDB SDK, HTTP protocol
surrealdb = { version = "2", default-features = false, features = ["protocol-http"] }


## Files & Responsibilities
- `src/config.rs` — reads env: HOST, PORT, SURREAL_URL, SURREAL_NS, SURREAL_DB, SURREAL_USER, SURREAL_PASS.
- `src/models.rs` — DTOs (e.g., `Guitar { id: Option<Thing>, brand, model, ... }` with `#[serde(default)]` where useful).
- `src/routes.rs` — JSON APIs under `/api`:
  - `GET /api/guitars` → list (use `db.select("guitars") -> Vec<Guitar>`).
  - `GET /api/guitars/{id}` → detail (accept `guitars:<id>` or `<id>`, use `db.select::<Option<Guitar>, _>(...)`).
- `src/main.rs` — Actix server:
  - Build Surreal client: `Surreal<Http>::new(url)`, `signin(Root{...})`, `use_ns/use_db`.
  - Register `/api/*` routes from `routes::config`.

## Code Patterns

### Surreal client (HTTP) in main.rs
```rust
use surrealdb::engine::remote::http::Http;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

let db: Surreal<Http> = Surreal::new(&cfg.surreal_url).await.expect("connect");
db.signin(Root{ username:&cfg.surreal_user, password:&cfg.surreal_pass }).await.expect("signin");
db.use_ns(&cfg.surreal_ns).use_db(&cfg.surreal_db).await.expect("use ns/db");
```

## SurQL Import Rules

### CLI Compatibility Requirements
- **NO hyphens in record IDs**: Use `guitars:banker_leslie` NOT `guitars:banker-leslie`
- **NO complex conditionals**: Avoid `IF/THEN/ELSE` blocks - use simple `CREATE` statements
- **NO scripting functions**: No `function` definitions or `CALL` statements
- **Terminate all statements**: Every statement must end with semicolon (`;`)
- **Use deterministic IDs**: Prefer explicit record IDs over auto-generated ones

### Data Import Pattern
```surql
-- Main guitar record (idempotent - won't create if exists)
CREATE guitars:brand_model CONTENT {
  brand: "Brand Name",
  model: "Model Name",
  slug: "model-slug",
  line: "Guitar Line",
  body_style: "Body Style"
} IF NOT EXISTS;

-- Related 1:1 tables (use guitar_id foreign key)
CREATE guitar_woods CONTENT {
  guitar_id: guitars:brand_model,
  body: "Body Wood",
  neck: "Neck Wood",
  fingerboard: "Fingerboard Wood"
};
```

### Schema Compliance
- Follow existing schema structure from `data/schema.surql`
- Each guitar gets main record + related 1:1 tables
- Use proper field names matching schema definitions
- Handle optional fields with empty strings if missing

### Preventing Duplicate Records

#### Method 1: `IF NOT EXISTS` (Recommended)
```surql
-- Won't create if record already exists
CREATE guitars:banker_leslie CONTENT {
  brand: "Banker",
  model: "Leslie"
} IF NOT EXISTS;
```

#### Method 2: `UPDATE` with `ON DUPLICATE KEY`
```surql
-- Updates existing or creates new
UPDATE guitars:banker_leslie CONTENT {
  brand: "Banker",
  model: "Leslie",
  updated_at: time::now()
} ON DUPLICATE KEY UPDATE updated_at = time::now();
```

#### Method 3: Check before create (for CLI compatibility)
```surql
-- Check if exists first
LET $exists = (SELECT id FROM guitars WHERE brand = "Banker" AND model = "Leslie");
IF $exists = [] THEN {
  CREATE guitars:banker_leslie CONTENT {
    brand: "Banker",
    model: "Leslie"
  };
};
```

#### Method 4: Use unique constraints in schema
```surql
-- In schema.surql - prevents duplicates at DB level
DEFINE INDEX idx_guitars_brand_model ON TABLE guitars COLUMNS brand, model UNIQUE;
```

### Import Command
```bash
# Load environment variables
set -a; source .env; set +a

# Run import script
surreal import --conn "https://$SURREAL_URL" --user "$SURREAL_USER" --pass "$SURREAL_PASS" \
  --ns "$SURREAL_NS" --db "$SURREAL_DB" \
  < data/import_script.surql


```

## SurrealDB Script Rules

### Schema Definition Files
- **Use `IF NOT EXISTS`** for all `DEFINE TABLE`, `DEFINE FIELD`, `DEFINE INDEX` statements
- **Schema-only files** should contain NO data import statements (`CREATE`, `INSERT`, `UPDATE`)
- **Required fields**: `guitars` table must include `slug` field (required, not optional)
- **Foreign keys**: Use `record<parent_table>` type for all foreign key fields

### Data Import Files
- **Capture record IDs**: Use `LET $var = (CREATE ... RETURN AFTER)[0];` pattern
- **Foreign key relationships**: Use `$var.id` for all related records
- **Avoid duplicates**: Use unique model names, slugs, or timestamps
- **Required fields**: Always include all required fields (brand, model, slug for guitars)

### Common Patterns
```sql
-- Guitar creation pattern
LET $g = (CREATE guitars CONTENT { brand: "Brand", model: "Unique Model", slug: "unique-slug" } RETURN AFTER)[0];
CREATE guitar_dimensions CONTENT { guitar_id: $g.id, ... };
CREATE guitar_appointments CONTENT { guitar_id: $g.id, ... };
```

### File Organization
- `schema_only.surql` - Pure schema definitions (no data)
- `data_seed.surql` - Data import scripts (no schema)
- `migrations/YYYYMMDD_description.surql` - Schema migrations
- `run_script_name.sh` - Shell scripts to execute SurQL files
